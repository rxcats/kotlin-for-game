# Kotlin for 게임서버 프로젝트

## 소개

- Spring Boot 와 Kotlin 을 이용하여 빠르게 서버 컨텐츠를 만들기 위해 사용하던 기능들을 모아보았습니다.
- MyBatis 를 확장하여 구현한 MyBatis Plus 를 이용 Query 없이 Entity 를 이용하여 DB 기능을 수행할 수 있습니다.
- RoutingDataSource 를 이용하여 DB 샤딩 기능을 사용할 수 있습니다.
- AWS SDK 기능 사용시 AWS 키 인증과 IAM 인증 방식을 선택하여 사용할 수 있습니다.
- AWS DynamoDB 기능을 DynamoOperations 를 확장하여 Repository 를 만들어 기본기능을 이용할 수 있습니다.
- Redisson 을 이용하여 Redis 캐시 기능 및 분산락 을 사용할 수 있습니다.
- Servlet Filter 를 이용한 요청, 응답 메시지를 로깅할 수 있습니다.

## 요구사항

- MySQL 8.0.x Server
- DynamoDB Local
- Redis Server

## 패키지 구조

```
.
├── core : 공통 라이브러리
├── module-aws-auth : AWS 인증 설정
├── module-aws-dynamodb : AWS DynamoDB 컴포넌트
├── module-database : MyBatis Plus 및 RoutingDataSource 컴포넌트
├── module-mybatis-plus : MyBatis Plus kotlin dsl 확장함수
├── module-redisson : Redisson Cache, Lock 컴포넌트
├── module-web : Filter 등 web 컴포넌트
└── sample-database : MyBatis Plus 예시 API 프로젝트
```

## 구성

### MyBatis Plus

- MyBatis 를 SQL 을 직접 작성하지 않고 Entity 로 사용할 수 있도록 Wrapping 한 라이브러리
- https://github.com/baomidou/mybatis-plus

#### application.properties db 설정

```
# mybatis plus configuration
mybatis-plus.configuration.map-underscore-to-camel-case=true
mybatis-plus.global-config.banner=false

app.db.driver-class-name=com.mysql.cj.jdbc.Driver

# commondb 는 샤드를 사용하지 않고 1개의 db 만 사용합니다.
app.db.info.commondb.shard-targets=1

# userdb 는 샤드 2개를 사용합니다.
app.db.info.userdb.shard-targets=1,2

# commondb : 공통으로 사용하는 db 이고, 샤딩을 하지 않습니다.
app.db.hikari.commondb.jdbc-url=jdbc:mysql://localhost:3306/route_commondb?serverTimezone=UTC
app.db.hikari.commondb.username=
app.db.hikari.commondb.password=
app.db.hikari.commondb.max-pool-size=1
app.db.hikari.commondb.connection-timeout=5s

# userdb : 유저 데이터를 샤딩하여 사용하는 db 입니다. 여기에서는 2개로 샤딩을 설정하였습니다.
# userdb[1] : 샤드 1번
app.db.hikari.userdb1.jdbc-url=jdbc:mysql://localhost:3306/route_userdb1?serverTimezone=UTC
app.db.hikari.userdb1.username=
app.db.hikari.userdb1.password=
app.db.hikari.userdb1.max-pool-size=1
app.db.hikari.userdb1.connection-timeout=5s

# userdb[2] : 샤드 2번
app.db.hikari.userdb2.jdbc-url=jdbc:mysql://localhost:3306/route_userdb2?serverTimezone=UTC
app.db.hikari.userdb2.username=
app.db.hikari.userdb2.password=
app.db.hikari.userdb2.max-pool-size=1
app.db.hikari.userdb2.connection-timeout=5s

```

#### Programmatic

```kotlin
@Service
class UserService(
    private val commonUserMapper: CommonUserMapper
) {
    fun getCommonUser(userId: String): CommonUser? = RoutingQuery(db = DbType.COMMON) {
        commonUserMapper.selectById(userId)
    }
}
```

#### AOP

```kotlin
@Service
class UserService(
    private val commonUserMapper: CommonUserMapper
) {

    @TargetDatabase(db = DbType.COMMON.get())
    fun getCommonUser(userId: String): CommonUser? = commonUserMapper.selectById(userId)

    @TargetDatabase(db = DbType.COMMON.get(), useTransaction = true)
    fun insertUserWithTransaction(user: CommonUser) {
        commonUserMapper.insert(user)
    }
}
```

### Redisson Cache

#### Programmatic

```kotlin
@Service
class UserService(
    private val cacheClient: RedissonCacheClient,
    private val commonUserMapper: CommonUserMapper
) {

    fun getCommonUser(userId: String): CommonUser? = cacheClient.withCache("commonUser:$userId", 5.minutes) {
        commonUserMapper.selectById(userId)
    }.getOrNull()

}
```

### Redisson Lock

#### Programmatic

```kotlin
@Service
class LockService(
    private val lockClient: RedissonLockClient
) {
    fun lockOperation() = lockClient.withLock(name = name = "LockTest", maxRetry = 3, waitForLockTime = 5.seconds) {
        // ...
    }

}
```

#### AOP

```kotlin
@Service
class LockService {
    @RedissonLock(name = "LockTest", waitForLockTime = "5s", maxRetry = 3)
    fun lockOperation() {
        // ...
    }

}
```

### DynamoDB

- AWS SDK for Java 2.x 를 이용하였고 Enhanced Client 를 사용하도록 되어 있습니다.
- 사용 편의성을 위해 abstract DynamoOperations 를 이용할 수 있도록 하였습니다.

#### DynamoDB Operations

```kotlin
@DynamoDbTableMeta(tableName = "user")
@DynamoDbBean
data class User(
    @get:DynamoDbPartitionKey
    var pk: String = "",

    var userId: String = "",
    var nickname: String = "",

    @get:DynamoDbAutoGeneratedTimestampAttribute
    @get:DynamoDbUpdateBehavior(UpdateBehavior.WRITE_IF_NOT_EXISTS)
    var createdDate: Instant? = null,

    @get:DynamoDbAutoGeneratedTimestampAttribute
    @get:DynamoDbUpdateBehavior(UpdateBehavior.WRITE_ALWAYS)
    var updatedDate: Instant? = null
) {
    companion object {
        fun of(userId: String): User {
            return User(pk = userId, userId = userId)
        }
    }
}

@Repository
class UserRepository : DynamoOperations<User>(User::class) {
    fun findById(userId: String): User? {
        val key = Key.builder()
            .partitionValue(userId)
            .build()
        return super.findByKey(key)
    }
}

@Service
class UserService(
    private val repository: UserRepository
) {
    fun findUser(userId: String): User? = repository.findById(userId)

    fun saveUser(user: User) = repository.save(user)
}
```
