# Kotlin for 게임서버 프로젝트

## 소개

- Spring Boot 와 Kotlin 을 이용하여 빠르게 서버 컨텐츠를 만들기 위해 사용하던 기능들을 모아보았습니다.
- MyBatis 를 확장하여 구현한 MyBatis Flex 를 이용 Query 없이 Entity 를 이용하여 DB 기능을 수행할 수 있습니다.
- RoutingDataSource 를 이용하여 DB 샤딩 기능을 사용할 수 있습니다.
- AWS SDK 기능 사용시 AWS 키 인증과 IAM 인증 방식을 선택하여 사용할 수 있습니다.
- AWS DynamoDB 기능을 DynamoOperations 를 확장하여 Repository 를 만들어 기본기능을 이용할 수 있습니다.
- Redisson 을 이용하여 Redis 캐시 기능 및 분산락 을 사용할 수 있습니다.
- Servlet Filter 를 이용한 요청, 응답 메시지를 로깅할 수 있습니다.

## 요구사항

- MySQL 8.0.x Server
- DynamoDB Local
- Redis Server

## 패키지 구조

```
.
├── core : 공통 라이브러리
├── module-aws-auth : AWS 인증 설정
├── module-aws-dynamodb : AWS DynamoDB 컴포넌트
├── module-database : MyBatis Flex 컴포넌트
├── module-mybatis-flex : MyBatis Flex 디펜던시 및 설정
├── module-redisson : Redisson Cache, Lock 컴포넌트
├── module-web : Filter 등 web 컴포넌트
└── sample-app : 예시 API 프로젝트
```

## 구성

### MyBatis Flex

- MyBatis 를 SQL 을 직접 작성하지 않고 Entity 로 사용할 수 있도록 Wrapping 한 라이브러리
- https://github.com/mybatis-flex/mybatis-flex

#### application.properties db 설정

```
# mybatis flex configuration
mybatis-flex.configuration.map-underscore-to-camel-case=true
mybatis-flex.global-config.print-banner=false

# user[1] : 샤드 1번
mybatis-flex.datasource.user1.url=jdbc:mysql://localhost:3306/sample_app_user01?serverTimezone=UTC
mybatis-flex.datasource.user1.username=root
mybatis-flex.datasource.user1.password=

# user[2] : 샤드 2번
mybatis-flex.datasource.user2.url=jdbc:mysql://localhost:3306/sample_app_user02?serverTimezone=UTC
mybatis-flex.datasource.user2.username=root
mybatis-flex.datasource.user2.password=

```

#### Programmatic

```kotlin
@Service
class UserService(
    private val userMapper: UserMapper
) {
    fun getUser(userId: String): User? = RoutingQuery(db = "user1") {
        userMapper.selectOneById(userId)
    }
}
```

### Redisson Cache

#### Programmatic

```kotlin
@Service
class UserService(
    private val cacheClient: RedissonCacheClient,
    private val userMapper: UserMapper
) {

    fun getUser(userId: String): User? = RoutingQuery(db = "user1") {
        userMapper.selectOneById(userId)
    }

    fun getUserViaCache(userId: String): User? = cacheClient.withCache("user:$userId", 5.minutes) {
        getUser(userId)
    }

}
```

### Redisson Lock

#### Programmatic

```kotlin
@Service
class LockService(
    private val lockClient: RedissonLockClient
) {
    fun lockOperation() = lockClient.withLock(name = name = "LockTest", maxRetry = 3, waitForLockTime = 5.seconds) {
        // ...
    }

}
```

#### AOP

```kotlin
@Service
class LockService {
    @RedissonLock(name = "LockTest", waitForLockTime = "5s", maxRetry = 3)
    fun lockOperation() {
        // ...
    }

}
```

### DynamoDB

- AWS SDK for Java 2.x 를 이용하였고 Enhanced Client 를 사용하도록 되어 있습니다.
- 사용 편의성을 위해 abstract DynamoOperations 를 이용할 수 있도록 하였습니다.

#### DynamoDB Operations

```kotlin
@DynamoDbTableMeta(tableName = "user")
@DynamoDbBean
data class User(
    @get:DynamoDbPartitionKey
    var pk: String = "",

    var userId: String = "",
    var nickname: String = "",

    @get:DynamoDbAutoGeneratedTimestampAttribute
    @get:DynamoDbUpdateBehavior(UpdateBehavior.WRITE_IF_NOT_EXISTS)
    var createdDate: Instant? = null,

    @get:DynamoDbAutoGeneratedTimestampAttribute
    @get:DynamoDbUpdateBehavior(UpdateBehavior.WRITE_ALWAYS)
    var updatedDate: Instant? = null
) {
    companion object {
        fun of(userId: String): User {
            return User(pk = userId, userId = userId)
        }
    }
}

@Repository
class UserRepository : DynamoOperations<User>(User::class) {
    fun findById(userId: String): User? {
        val key = Key.builder()
            .partitionValue(userId)
            .build()
        return super.findByKey(key)
    }
}

@Service
class UserService(
    private val repository: UserRepository
) {
    fun findUser(userId: String): User? = repository.findById(userId)

    fun saveUser(user: User) = repository.save(user)
}
```

## 성능테스트 (Undertow, Webflux)

[성능테스트 결과](./perf-test/README.md)
