package io.github.rxcats.dynamodb.ops

import io.github.rxcats.aws.dynamodb.DynamoConfig
import io.github.rxcats.aws.dynamodb.DynamoDefine
import io.github.rxcats.aws.dynamodb.ops.DynamoDbTableMeta
import io.github.rxcats.aws.dynamodb.ops.DynamoOperations
import io.github.rxcats.aws.dynamodb.ops.DynamoTransactionOperations
import io.github.rxcats.aws.dynamodb.ops.TranLoadItem
import io.github.rxcats.aws.dynamodb.ops.TranWriteItem
import io.github.rxcats.aws.dynamodb.ops.TranWriteMode
import io.github.rxcats.core.spring.ApplicationContextProviderInitializer
import org.assertj.core.api.Assertions.assertThat
import org.junit.jupiter.api.AfterAll
import org.junit.jupiter.api.BeforeAll
import org.junit.jupiter.api.Test
import org.springframework.beans.factory.annotation.Autowired
import org.springframework.boot.test.context.SpringBootTest
import org.springframework.stereotype.Repository
import software.amazon.awssdk.enhanced.dynamodb.extensions.annotations.DynamoDbAutoGeneratedTimestampAttribute
import software.amazon.awssdk.enhanced.dynamodb.mapper.UpdateBehavior
import software.amazon.awssdk.enhanced.dynamodb.mapper.annotations.DynamoDbBean
import software.amazon.awssdk.enhanced.dynamodb.mapper.annotations.DynamoDbPartitionKey
import software.amazon.awssdk.enhanced.dynamodb.mapper.annotations.DynamoDbSortKey
import software.amazon.awssdk.enhanced.dynamodb.mapper.annotations.DynamoDbUpdateBehavior
import java.time.Instant

@SpringBootTest(classes = [ApplicationContextProviderInitializer::class, DynamoConfig::class, DynamoTransactionOperationsTest.UserItemRepository::class])
class DynamoTransactionOperationsTest {

    @DynamoDbTableMeta(tableName = "user_item")
    @DynamoDbBean
    data class UserItem(
        @get:DynamoDbPartitionKey
        var pk: String = "",

        @get:DynamoDbSortKey
        var sk: String = "",

        var userId: String = "",
        var itemId: Int = 0,
        var itemQty: Int = 0,

        @get:DynamoDbAutoGeneratedTimestampAttribute
        @get:DynamoDbUpdateBehavior(UpdateBehavior.WRITE_IF_NOT_EXISTS)
        var createdDate: Instant? = null,

        @get:DynamoDbAutoGeneratedTimestampAttribute
        @get:DynamoDbUpdateBehavior(UpdateBehavior.WRITE_ALWAYS)
        var updatedDate: Instant? = null
    ) {
        companion object {
            const val SK = "USER_ITEM"

            fun of(userId: String, itemId: Int, itemQty: Int): UserItem = UserItem(
                pk = userId,
                sk = sk(userId, itemId),
                userId = userId,
                itemId = itemId,
                itemQty = itemQty
            )

            fun sk(userId: String, itemId: Int) = "$SK#$userId#$itemId"
        }
    }

    @Repository
    class UserItemRepository : DynamoOperations<UserItem>(UserItem::class)

    companion object {
        @JvmStatic
        @BeforeAll
        fun beforeAll(@Autowired repository: UserItemRepository) {
            repository.createTableIfNotExists()
        }

        @JvmStatic
        @AfterAll
        fun afterAll(@Autowired repository: UserItemRepository) {
            repository.deleteTable()
        }
    }

    @Autowired
    private lateinit var ops: DynamoTransactionOperations

    @Test
    fun transactionWriteAndLoad() {
        ops.transactionWrite(
            listOf(
                TranWriteItem(item = UserItem.of("junitUser1", 10001, 1), TranWriteMode.UPDATE),
                TranWriteItem(item = UserItem.of("junitUser1", 10002, 1), TranWriteMode.UPDATE)
            )
        )

        val targets = listOf(
            TranLoadItem(UserItem.of("junitUser1", 10001, 1)),
            TranLoadItem(UserItem.of("junitUser1", 10002, 1))
        )

        val result = ops.transactionLoad(targets)

        val userGame = result.get<UserItem>(0)
        val userItem = result.get<UserItem>(1)

        assertThat(userGame).isNotNull()
        assertThat(userItem).isNotNull()
    }

    @Test
    fun transactionChunkedWrite() {
        val targets = mutableListOf<TranWriteItem<UserItem>>()
        val readTargets = mutableListOf<TranLoadItem<UserItem>>()

        repeat(DynamoDefine.TRAN_WRITE_MAX_ITEM.count + 10) { i ->
            targets += TranWriteItem(UserItem.of("user#${1001 + i}", 1001 + i, 1), TranWriteMode.UPDATE)
            readTargets += TranLoadItem(UserItem.of("user#${1001 + i}", 1001 + i, 1))
        }

        ops.transactionWrite(targets)

        val result = ops.transactionLoad(readTargets)

        assertThat(result.results).hasSize(DynamoDefine.TRAN_WRITE_MAX_ITEM.count + 10)

        repeat(DynamoDefine.TRAN_WRITE_MAX_ITEM.count + 10) { i ->
            val userGame = result.get<UserItem>(i)

            assertThat(userGame).isNotNull()
        }

    }

}

